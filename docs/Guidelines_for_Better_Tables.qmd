---
title: "The Mockup - gt Tables Tutorial"
format: html
editor: visual
execute: 
  echo: false
  warning: false
  message: false
---

```{r}
#| echo: false
#| message: false

library(stringr) # Simple, Consistent Wrappers for Common String Operations
library(gt) # Easily Create Presentation-Ready Display Tables
library(janitor) # Simple Tools for Examining and Cleaning Dirty Data
library(tidyverse) # Easily Install and Load the 'Tidyverse'
library(here) # A Simpler Way to Find Your Files
library(readr) # Read Rectangular Text Data
library(annotater) # Annotate Package Load Calls

```

Tom Mock published a tutorial in *The* blog demonstrating the *gt* package[^1]. Tom's blog was inspired by the work of J. A. Schwabish (2020). Tom's tutorial reproduced here, contains minor changes to Tom Mock's code. Some of Tom's code has been deprecated and I introduce other minor changes to Tom's code, including accessing the Tidy Tuesday data source as a csv file and importing the data set directly with the {*readr*} package. Otherwise, the material is close to a *verbatim* reproduction of Tom's tutorial.

[^1]: Developed by Richard Iannone, Joe Cheng, Barret Schloerke, Ellis Hughes, JooYoung Seo, RStudio.

Complementing *The Mockup* tutorial on creating tables in R with the *gt* package, David Keyes of *RfortheRestofUs* created a YouTube tutorial [Making high-quality tables in R with the gt package: a conversation with Tom Mock.](https://www.youtube.com/watch?v=dxDeotwylr8). David's tutorial illustrates how to access the Tidy Tuesday data sets. Tom Mock's tutorial references the Tidy Tuesday data set but does not explain how to retrieve the data. Keyes' tutorial discusses Mock's code and the table guidelines introduced by J.A. Schwabish.

**Package versions**

-   R 4.2.2\
-   RStudio 2022.12.0+353 "Elsbeth Geranium" Release (2022-12-03) for Windows
-   {*gt*} version 0.6.0.
    -   Current version of {*gt*} is 0.7.0. Using 0.7.0, I had failure in creating parameterized reports, so I uninstalled 0.7.0 and re-installed 0.6.0.

[The Mockup 10+ Guidelines for Better Tables in R](https://themockup.blog/posts/2020-09-04-10-table-rules-in-r/)

[R for the rest of Us YouTube Tutorial {gt} package](https://www.youtube.com/watch?v=dxDeotwylr8)

Schwabish, J. A. (2020). Ten Guidelines for Better Tables. Journal of Benefit-Cost Analysis, 11(2), 151--178. https://doi.org/10.1017/bca.2020.11

![Table Parts \@jschwabish, 2020](images/table_parts.jpg)[^2] Figure 1. Table Parts (Schwabish, 2020)

[^2]: @jschwabish Tweet Aug 3, 2020

[click here for the Rstudio *gt* site](https://gt.rstudio.com/)

```{r load_data, eval=FALSE}
#\| echo: false
#\| message: false
# tuesData \<- tidytuesdayR::tt_load(2020, "36")
## yield_data <- tuesData$key_crop_yields

```

```{r original_data}
# Also:
# arable_land_pin \<- tuesData\$arable_land_pin
# cereal_crop_yield_vs_fertilizer \<- tuesData\$cereal_crop_yield_vs_fertilizer_application
# key_crop_yields \<- tuesData\$key_crop_yields
# cereal_yields_vs_tractor_inputs_in_agriculture \<- tuesData\$cereal_yields_vs_tractor_inputs_in_agriculture
# land_use_vs_yield_change_in_cereal_production \<- tuesData\$land_use_vs_yield_change_in_cereal_production
# 
# 
# write_csv(yield_data, here("data/yield_data.csv"))
# write_csv(arable_land_pin, here("data/arable_land_pin.csv"))
# write_csv(cereal_crop_yield_vs_fertilizer, here("data/cereal_crop_yield_vs_fertilizer.csv"))
# write_csv(cereal_yields_vs_tractor_inputs_in_agriculture, here("data/cereal_yields_vs_tractor_inputs_in_agriculture.csv"))
# write_csv(land_use_vs_yield_change_in_cereal_production, here("data/land_use_vs_yield_change_in_cereal_production.csv"))
```

```{r}
#| echo: false
#| message: false

## ----- tuesData loaded and saved to csv to /data/...  2022-12-21  ***  ----
## tuesData <- tidytuesdayR::tt_load(2020, "36") 
## -----------------------------------------------------------


yield_data <- read_csv(here("data/yield_data.csv"))



# country_sel <- c("China", "India", "United States", "Indonesia", "Mexico", "Pakistan")

## yield_data <- tuesData$key_crop_yields %>% 
# yield_data <- yield_data %>% 
#   clean_names() %>% 
#   rename_with(~str_remove(., "_tonnes_per_hectare")) %>% 
#   select(entity:beans, code) %>% 
#   pivot_longer(cols=wheat:beans, names_to = "crop", values_to = "yield") %>% 
#   rename(Country = entity)
```

## Rule 1: Offset heads from body

-   Tidy format is not the best for presentation\
-   Make the table wider\
-   Make column titles clear
    -   Offset column titles with boldface type or lines
-   Using *filter(var %in% c("var1", "var2"))*\
-   cols\_\_hide()

```{r}
country_sel1 <- c("China", "India", "Indonesia", "Mexico", "United States")
crop_sel <- c("maize", "potatoes")

yield_data %>% 
   filter(Country %in% country_sel1, crop %in% crop_sel, year %in% c(2014:2016)) %>% 
  pivot_wider(names_from = year, values_from = yield) %>% 
gt() %>% 
  cols_hide(columns = c(code))
  
```

### Pivot Wider

```{r potato_data_rule1_good}

country_sel <- c("China", "India", "United States", "Indonesia", "Mexico", "Pakistan")

potato_data <- yield_data %>% 
  select(-code) %>% 
  filter(Country %in% country_sel, crop == "potatoes", year %in% c(2013:2016)) %>% 
  filter(crop=="potatoes") %>% 
  pivot_wider(names_from = year, values_from = "yield")   

potato_tb <- potato_data %>% 
  gt() %>% 
  cols_hide(columns = c(crop)) %>% 
  opt_table_lines(extent = "none") %>% 
  fmt_number(
    columns = 3:6,
    decimals = 2
  ) 

rule1_good <- potato_tb %>% 
  tab_style(
    style = list(
      cell_text(weight = "bold")
    ),
    locations = cells_column_labels(everything())
  ) %>% 
  opt_table_lines(extent = "default") %>%
  tab_options(
    column_labels.border.top.color = "white",
    column_labels.border.top.width = px(3),
    column_labels.border.bottom.color = "black",
    table_body.hlines.color = "white",
    table.border.bottom.color = "white",
    table.border.bottom.width = px(3)
  ) %>% tab_source_note(md("**Table**: @thomas_mock | **Data**: OurWorldInData.org<br>**Inspiration**: @jschwabish"))

rule1_good
```

### Rule 2: Use subtle Dividers rather than heavy gridlines

-   tab_style()\
-   see stackoverflow to conditionally fill tab_style[^3]

[^3]: https://stackoverflow.com/questions/63944953/how-to-conditionally-format-a-cell-in-a-gt-table-based-on-the-value-of-the-cel

```{r subtle_dividers}

#| echo: true 
rule2_data <- yield_data %>% 
  filter(Country %in% country_sel, crop == "potatoes", year %in% c(2007:2016)) %>% 
  filter(crop == "potatoes") %>% 
  select(-crop) %>% 
  pivot_wider(names_from = year, values_from = "yield") %>% 
  rowwise() %>% 
  mutate(
    avg_07_11 = mean(`2007`:`2011`),
    .before = `2012`
    ) %>% 
  mutate(
    avg_12_16 = mean(`2012`:`2016`)
  ) %>% 
  ungroup()

rule2_data %>% 
  gt() %>% 
  tab_style(style = cell_fill(color = "lightgrey"),
                   locations = cells_body(columns = c("avg_07_11", "avg_12_16")))


```

-   Create gt object, then loop over the sequence of rows in a for-loop to color the argument in cell_fill.\
-   getting an error "The following row indices do not exist in the data: 7

```{r eval=FALSE}

yield_data <- yield_data %>%
  drop_na() 


heat_palette <- leaflet::colorNumeric(palette = "YlOrRd",
                                      domain =mean(yield_data$yield))
ht_values <- heat_palette(yield_data$yield)

getobj <- gt(rule2_data)
getobj

for(i in seq_along(yield_data$yield)) {
   getobj <- getobj %>%
         tab_style(style = cell_fill(color = ht_values[i]),
                   locations = cells_body(columns = "avg_07_11", rows = i))
}

getobj

rule2_data <- yield_data %>% 
  filter(Country %in% country_sel, crop == "potatoes", year %in% c(2007:2016)) %>% 
  filter(crop == "potatoes") %>% 
  select(-crop) %>% 
  pivot_wider(names_from = year, values_from = "yield") %>% 
  rowwise() %>% 
  mutate(
    avg_07_11 = mean(`2007`:`2011`),
    .before = `2012`
    ) %>% 
  mutate(
    avg_12_16 = mean(`2012`:`2016`)
  ) %>% 
  ungroup()

rule2_data %>% 
  gt() %>% 
  tab_style(style = cell_fill(color = "lightgrey"),
                   locations = cells_body(columns = c("avg_07_11", "avg_12_16")))


```

### Rule 3. Right-Align Numbers and Heads

In this case, you want to right align numbers and ideally choose mono-spaced or numerically-aligned fonts, while avoiding "old style" fonts which have numbers with varying vertical placement. Importantly, gt already automatically follows best practices for the most part so we have to change some of the defaults to get bad example.

### 3. Addendums to alignment

-   Center Align: When aligning text of equal length (long or very short), center alignment of text can be fine or even preferable. For example, very *short text with a long header* can be better suited to center-align.

-   Equal length text can be centered without negatively affecting the ability to quickly read.

```{r}
rule3_data_addendum <- yield_data %>% 
  filter(
    Country %in% c("United States"), 
    year >= 2015,
    str_length(crop) == 5
    ) %>%
  group_by(year) %>% 
  mutate(
    crop = str_to_title(crop),
    max_yield = max(yield),
    `Top Crop` = if_else(yield == max_yield, "Y", "N")
    ) %>%
  select(Year = year, Crop = crop, `Top Crop`, Yield = yield) %>% 
  ungroup()
```

While the table below could be improved in other ways and has quite a bit of repetition, note that the Top Crop column has too much white space on the right side due to defaulting to left-alignment. This makes it "stick" too much to the adjacent column.

```{r}
rule3_data_addendum %>% 
  gt()
```

Moving the Top Crop column to center-alignment makes it easier to visually parse the column, and note that centering the Crop Column has no negative effect on the alignment or ability to read as each cell value has equal length (as long as the font-choice is one that doesn't have major differences in character width). The left-alignment rule for text is a good default, but is more effective with variable width text especially with large variation (i.e. length = 10 interspersed with length = 5).

```{r}
rule3_data_addendum %>% 
  gt() %>% 
  gt::cols_align(
    align = "center",
    columns = c(`Top Crop`, Crop)
  )

```

### Pivot wider to improve table

```{r}
rule3_data_addendum %>% 
  pivot_wider(names_from = Year, values_from = Yield) %>% 
  gt() %>% 
  gt::cols_align(
    align = "center",
    columns = c(`Top Crop`)
  ) 
```

### Rule 4: Left-align Text and Heads

**For labels/strings** it is typically more appropriate to left-align. This allows your eye to follow both short and long text vertically to scan a table, along with a clear border.

-   cols_label( left = md("Left-aligned and<br>easiest to read") )

```{r}
country_names <- c(
  "British Virgin Islands",
  "Cayman Islands",
  "Democratic Republic of Congo",
  "Luxembourg", 
  "United States",
  "Germany",
  "New Zealand",
  "Costa Rica",
  "Peru"
)

rule4_tab_left <- tibble(
  right = country_names,
  center = country_names,
  left = country_names
) %>% 
  gt()  %>% 
  cols_align(align = "left",
             columns = 3) %>% 
  cols_align(align = "center",
             columns = 2) %>% 
  cols_align(align = "right",
             columns = 1) %>% 
  cols_width(
    everything() ~ px(250)
  ) %>% 
  tab_options(
    column_labels.border.top.color = "white",
    column_labels.border.top.width = px(3),
    column_labels.border.bottom.color = "black",
    column_labels.font.weight = "bold",
    table_body.hlines.color = "white",
    table.border.bottom.color = "white",
    table.border.bottom.width = px(3),
    data_row.padding = px(3)
  ) %>% 
  cols_label(
    right = md("Right aligned and<br>hard to read"),
    center = md("Centered and<br>even harder to read"),
    left = md("Left-aligned and<br>easiest to read")
  ) %>% 
  tab_source_note(md("**Table**: @thomas_mock | **Data**: OurWorldInData.org<br>**Inspiration**: @jschwabish"))

rule4_tab_left


```

### Rule 5: Select the Appropriate Level of Precision

While you can sometimes justify increased decimal places, often 1 or 2 can help with the appearance of the table and clean up the overall flow. Additionally, for many measure the accuracy in your data set may be more detailed than what is appropriate from the data collection tool itself.

**Rule 5 \| Precision gt code**

```{r}
rule5_tab <- yield_data %>% 
  filter(Country %in% country_sel, crop == "potatoes", year %in% c(2016)) %>% 
  select(Country, yield) %>% 
  mutate(few = yield, right = yield) %>% 
  gt() %>% 
  fmt_number(
    columns = c(few),
    decimals = 0
  ) %>% 
  fmt_number(
    columns = c(right),
    decimals = 1
  ) %>% 
  cols_label(
    yield = md("Too many<br>decimals"),
    few = md("Too few<br>decimals"),
    right = md("About<br>right")
  ) %>% 
  tab_source_note(md("**Table**: @thomas_mock | **Data**: OurWorldInData.org<br>**Inspiration**: @jschwabish"))
```

### Rule 6: Guide Your Reader with <ins>Space between Rows and Columns</ins>

While there is a bit of art to the science of spacing - think of how you want to guide the reader. You want to make it easy to move horizontally and/or vertically depending on the purpose of the table. Additionally, increasing spacing can improve the overall readability of the table although TOO much space can be distracting.

```{r}
rule6_data <- yield_data %>% 
  filter(Country %in% country_sel, crop == "potatoes", year %in% c(2014:2016)) %>% 
  filter(crop == "potatoes") %>% 
  pivot_wider(names_from = year, values_from = "yield") %>% 
  select(-crop)

##### ---------------------------ADD "AVERAGE"  Row ---------------------------
rule6_tb <- rule6_data %>% 
  add_row(
    rule6_data %>% 
      summarize(
        across(where(is.double), 
               list(Average = mean),
               .names = "{col}")
      ) %>% 
      mutate(Country = "Average")
  )

rule6_tb %>% 
  gt()


rule6_tb1 <- rule6_tb %>% 
  select(-code) %>% 
  gt() %>% 
#  cols_hide(columns = code) %>%   
## -----------------------------------format number ------------------- 
  fmt_number(
    columns = 2:4,
    decimals = 2
  ) %>% 
  
## -------------------------------bold the column labels  -------------------
  tab_style(
    style = list(
      cell_text(weight = "bold")
    ),
    locations = cells_column_labels(everything())
  ) %>% 
  
## ------------------------------------ADD CELL BORDER --------------------
  tab_style(
    style = cell_borders(
      sides = "top",
      color = "black",
      weight = px(2)
    ),
    locations = cells_body(
      columns = everything(),
      rows = Country == "Average"
    )
  ) %>% 
  
## ========================= ADD BORDER COLORS =========================
  tab_options(
    column_labels.border.top.color = "white",
    column_labels.border.top.width = px(3),
    column_labels.border.bottom.color = "black",
    table_body.hlines.color = "white",
    table.border.bottom.color = "white",
    table.border.bottom.width = px(3)
      ) 

rule6_tb1

##%######################################################%##
#                                                          #
####               SPACE BETWEEN COLUMNS                ####
#                                                          #
##%######################################################%##


rule6_tb1 %>% 
   cols_width(
    '2014' ~ px(50),
    '2015' ~ px(150),
    ends_with("o") ~ px(100),
    starts_with("C") ~ px(200),
    everything() ~ px(60)
  )
  
  
  
#   cols_width(vars(Country) ~ px(125),
#             2:4 ~ px(75))
```

```{r}
rule6_tb1 %>% 
  tab_source_note(md("**Table**: @thomas_mock | **Data**: OurWorldInData.org<br>**Inspiration**: @jschwabish"))
```

### Rule 7: Remove Unit Repetition

The goal here is to remove repetition of units to improve readability and increase the signal to noise ratio in the table.

For our example, we are *dropping the % sign* after the first appearance. While this is easy to do with currency symbols at the start of the row, *the % sign at the end alters the alignment* of the cells. gt actually has an open Github Issue to allow for this feature, but in the meantime I have two strategies to accomplish the % trick as seen below.

```{r eval=FALSE}

##### =====================THIS CRASHES ===============================
rule6_tb1 %>% 
  fmt_percent(
    columns = c("2014", "2015", "2016"),
    rows = 3,
    scale_values = FALSE
  ) %>% 
  tab_source_note(md("**Table**: @thomas_mock | **Data**: OurWorldInData.org<br>**Inspiration**: @jschwabish"))
```

We can try to align left for examples that ALL have the same range (i.e. all in the 10's) as the numbers will align properly, although variation in the units can again mess up the alignment.

[Format values as a percentage is not working](https://gt.rstudio.com/reference/fmt_percent.html)[^4]

[^4]: Not working because the data source is a table and not a data frame

```{r}
rule6_tb1 %>% 
  fmt_percent( 
    columns = c("2015"),
    #columns = 2:4,
    rows = everything(),
    decimals = 2,
    scale_values = FALSE
  ) %>% 
  cols_align(
    columns = 2:4,
    align = "left"
  ) %>% 
  tab_source_note(md("**Table**: @thomas_mock | **Data**: OurWorldInData.org<br>**Inspiration**: @jschwabish"))
```

This example of *fmt_percent()* is from a data frame, not a gt object.

```{r}
rule2_data %>% 
  select(Country, 3:5) %>% 
  gt() %>% 
  
  fmt_percent( 
    columns = c("2007"),
    #columns = 2:4,
    rows = everything(),
    decimals = 2,
    scale_values = FALSE
  )
  
```

### *add the % sign to each of the column labels*

-   *Note*: [Format values as a percentage deserves its own presenation](https://gt.rstudio.com/reference/fmt_percent.html)

```{r}
rule2_data %>% 
  select(Country, 11:13) %>% 
  gt() %>% 
  
 cols_label(
    `2014` = "2014 (%)",
    `2015` = "2015 (%)",
    `2016` = "2016 (%)"
  ) %>% 
  cols_width(
    2:4 ~ px(100)
  )  %>% 
  
### ---------- BOLD COLUMN LABELS ------------------------
 tab_style(
    style = list(
      cell_text(weight = "bold")
    ),
    locations = cells_column_labels(everything())
  ) %>% 
  tab_source_note(md("**Table**: @thomas_mock | **Data**: OurWorldInData.org<br>**Inspiration**: @jschwabish"))
  
```

### Or add a spanner across the columns.

```{r}
rule2_data %>% 
  select(Country, 11:13) %>% 
  gt() %>% 
  
## ------------------------------------tab_spanner() -----------------------------------------
  tab_spanner(
    label = md("**% Yield of Total**"),
    columns = 2:4
  )  %>% 
  tab_source_note(md("**Table**: @thomas_mock | **Data**: OurWorldInData.org<br>**Inspiration**: @jschwabish"))
```

### Add footnote to each of the column labels

```{r}

rule2_data %>% 
  select(Country, 11:13) %>% 
  
  gt() %>% 
  tab_footnote(
    footnote = md("**% Yield of Total**"),
    locations = cells_column_labels(2:4)
  )  %>% 
  tab_source_note(md("**Table**: @thomas_mock | **Data**: OurWorldInData.org<br>**Inspiration**: @jschwabish"))
```

### Rule 8: Highlight Outliers

```{r}
rule8_data <- yield_data %>% 
  filter(Country %in% country_sel, crop == "potatoes", year %in% 2009:2017) %>% 
  group_by(Country) %>% 
  mutate(pct_change = (yield/lag(yield)-1)*100) %>% 
  ungroup() %>% 
  filter(between(year, 2010, 2016)) %>% 
  select(Country, year, pct_change) %>% 
  pivot_wider(names_from = year, values_from = pct_change)

rule8_tb <-  rule8_data %>% 
  gt() %>% 
  fmt_number(2:last_col()) %>% 
  cols_label(
    Country = ""
  ) %>% 
  tab_style(
    style = list(
      cell_text(weight = "bold")
    ),
    locations = cells_column_labels(everything())
  ) %>% 
  tab_options(
    column_labels.border.top.color = "white",
    column_labels.border.top.width = px(3),
    column_labels.border.bottom.color = "black",
    column_labels.border.bottom.width = px(3),
    table_body.hlines.color = "white",
    table.border.bottom.color = "black",
    table.border.bottom.width = px(3)
  ) %>% 
  cols_width(columns = c(Country) ~ px(125),
             2:last_col() ~ px(75))
  
 # rule8_tb %>%  
 #  gt() %>% 
 #  tab_source_note(md("**Table**: @thomas_mock | **Data**: OurWorldInData.org<br>**Inspiration**: @jschwabish"))
 # 


```

```{r}
rule8_tb %>% 
  tab_source_note(md("**Table**: @thomas_mock | **Data**: OurWorldInData.org<br>**Inspiration**: @jschwabish"))

rule8_tb
```

### Rule 8 \| Plain table gt code

```{r}
rule8_tb <- rule8_data %>% 
  gt() %>% 
  fmt_number(2:last_col()) %>% 
  cols_label(
    Country = ""
  ) %>% 
  tab_style(
    style = list(
      cell_text(weight = "bold")
    ),
    locations = cells_column_labels(everything())
  ) %>% 
  tab_options(
    column_labels.border.top.color = "white",
    column_labels.border.top.width = px(3),
    column_labels.border.bottom.color = "black",
    column_labels.border.bottom.width = px(3),
    table_body.hlines.color = "white",
    table.border.bottom.color = "black",
    table.border.bottom.width = px(3)
  ) %>% 
  cols_width(columns = c(Country) ~ px(125),
             2:last_col() ~ px(75)) %>% 
  

  tab_source_note(md("**Table**: @thomas_mock | **Data**: OurWorldInData.org<br>**Inspiration**: @jschwabish"))
  
rule8_tb
```

-   The plain data we don't fully recognize the negative values instantly.

-   Add color to focus on outliers

```{r}
rule8_color <- rule8_tb %>% 
  tab_style(
    style = cell_text(color = "red"),
    
    locations = list(
      
      cells_body(
        columns = 2,
        rows = `2010` < 0
    ),
    cells_body(
      columns = 3,
      rows = `2011` < 0
    ),
    cells_body(
      columns = 4,
      rows = `2012` < 0
    ),
    cells_body(
      columns = 5,
      rows = `2013` < 0
    ),
    cells_body(
      columns = 6,
      rows = `2014` < 0
    ),
    cells_body(
      columns = 7,
      rows = `2015` < 0
    ),
    cells_body(
      columns = 8,
      rows = `2016` < 0
    )
  )
  ) %>% 
  
  tab_source_note(md("**Table**: @thomas_mock | **Data**: OurWorldInData.org<br>**Inspiration**: @jschwabish")) 


```

```{r}
rule8_color
```

We can really pull the focus with background fill of each cell outlier.

### rULE 8 \| Cell fill *gt* code

```{r}
rule8_fill <- rule8_tb %>% 
  tab_style(
    style = list(
      cell_fill(color = scales::alpha("red", 0.7)),
      cell_text(color = "white", weight = "bold")
      ),
    locations = list(
      cells_body(
        columns = 2,
        rows = `2010` < 0
      ),
      cells_body(
        columns = 3,
        rows = `2011` < 0
      ),
      cells_body(
        columns = 4,
        rows = `2012` < 0
      ),
      cells_body(
        columns = 5,
        rows = `2013` < 0
      ),
      cells_body(
        columns = 6,
        rows = `2014` < 0
      ),
      cells_body(
        columns = 7,
        rows = `2015` < 0
      ),
      cells_body(
        columns = 8,
        rows = `2016` < 0
      )
    )
  ) %>% 
  tab_source_note(md("**Table**: @thomas_mock | **Data**: OurWorldInData.org<br>**Inspiration**: @jschwabish"))
```

```{r}
rule8_fill
```

### Rule 9: Group Similar Data and Increase White Space

In this rule, you want to make sure to **group similar categories** to make parsing the table easier. We can also *increase white space*, or even *remove repeats to increase the data-to-ink ratio*.

### 9. Bad Example

Here we can see the table is a bit hard to follow with the Country labels not being grouped.

**Rule 9 \| Bad example gt code**

```{r}

yield_data <- read_csv(here("data/yield_data.csv")) 
country_sel <- c("China", "India", "United States", "Indonesia", "Mexico", "Pakistan")

rule9_data <- yield_data %>% 
  filter(Country %in% country_sel[-5], year %in% c(2015, 2016),
         crop %in% c("wheat", "potatoes", "rice", "soybeans"),
         !is.na(yield)) %>% 
  pivot_wider(names_from = year, values_from = yield) %>% 
  rowwise() %>% 
  mutate(crop = str_to_title(crop),
         pct_change = (`2016`/`2015`-1)*100) %>%
  group_by(Country) %>% 
  arrange(desc(`2015`)) %>% 
  ungroup() 
```

**Includes tab_spanner()**

```{r}
rule9_bad <- rule9_data %>% 
  gt() %>% 
  fmt_number(
    columns = c(`2015`, `2016`, pct_change)
  ) %>% 
  tab_spanner(columns = c(`2015`, `2016`),
              label = md("**Yield in Tonnes/Hectare**")) %>%  
  cols_width(
    columns = c('crop') ~ px(125),
    columns = c('2015', '2016', pct_change) ~ px(100)
    #   vars(crop) ~ px(125),
#    vars(`2015`, `2016`, pct_change) ~ 100
  ) %>% 
  tab_source_note(md("**Table**: @thomas_mock | **Data**: OurWorldInData.org<br>**Inspiration**: @jschwabish"))
```

### 9. gt native grouping

gt provides *row group levels* that we can use to separate by Country.

**Rule 9 \| Groups gt code**

```{r}
rule9_grp <- rule9_data %>% 
  gt(groupname_col = "Country") %>% 
  tab_stubhead("label") %>% 
  tab_options(
    table.width = px(300)
  ) %>% 
  cols_label(
    crop = "",
    pct_change = md("Percent<br>Change")
  ) %>% 
  fmt_number(
    columns = c(`2015`, `2016`, pct_change)
  ) %>% 
  tab_style(
    style = cell_text(color = "black", weight = "bold"),
    locations = list(
      cells_row_groups(),
      cells_column_labels(everything())
    )
  ) %>% 
  tab_spanner(columns = c(`2015`, `2016`),
              label = md("**Yield in Tonnes/Hectare**")) %>%  
  cols_width(
    columns = c(crop) ~ px(125),
    columns = c(`2015`, `2016`, pct_change) ~ px(100)
  ) %>% 
  tab_options(
    row_group.border.top.width = px(3),
    row_group.border.top.color = "black",
    row_group.border.bottom.color = "black",
    table_body.hlines.color = "white",
    table.border.top.color = "white",
    table.border.top.width = px(3),
    table.border.bottom.color = "white",
    table.border.bottom.width = px(3),
    column_labels.border.bottom.color = "black",
    column_labels.border.bottom.width = px(2)
  ) %>% 
  tab_source_note(md("**Table**: @thomas_mock | **Data**: OurWorldInData.org<br>**Inspiration**: @jschwabish")) %>% 
   tab_header(
    title = md("Table with *Row Group Levels* to separate by country"),
    subtitle = md("From: 9 *gt* native grouping")
  )
```

```{r}
rule9_bad
```

### 9. Remove duplicate data

Alternatively, we can remove some observations to create more white space, similar to Jon's example. Here, we are relying purely on *white space rather than horizontal dividers*. We can use ***gt::text_transform()*** to keep all the observations from our data in, but not display, the repeats of Country in the gt table.

-   Use White Space rather than horizontal dividers\
-   Keep all observations but do not display repeats

### Rule 9 \| Group example gt code

```{r}
rule9_dup <- rule9_data %>% 
  arrange(Country) %>% 
  gt() %>% 
  cols_label(
    Country = "",
    crop = "Crop",
    pct_change = md("Percent<br>Change")
  ) %>% 
  tab_spanner(columns = c(`2015`, `2016`),
              label = md("**Yield in Tonnes/Hectare**")) %>% 
  fmt_number(
    columns = c(`2015`, `2016`, pct_change)
  ) %>% 
  text_transform(
    locations = cells_body(
      columns = c(Country),
      rows = crop != "Potatoes"
    ),
    fn = function(x){
      paste0("")
    }
  ) %>% 
  tab_style(
    style = cell_text(color = "black", weight = "bold"),
    locations = list(
      cells_row_groups(),
      cells_column_labels(everything())
    )
  ) %>% 
  cols_width(
    c(Country, crop) ~ px(125),
    c(`2015`, `2016`, pct_change) ~ 100
  ) %>% 
  tab_options(
    column_labels.border.bottom.color = "black",
    column_labels.border.bottom.width = px(2),
    table_body.hlines.color = "white",
    table.border.top.color = "white",
    table.border.top.width = px(3),
    table.border.bottom.color = "white",
    table.border.bottom.width = px(3),
  ) %>% 
  tab_source_note(md("**Table**: @thomas_mock | **Data**: OurWorldInData.org<br>**Inspiration**: @jschwabish"))
```

```{r}
rule9_dup
```

### Rule 10: Add visualizations When Appropriate

While data viz and tables are different tools, you can combine them in clever ways to further engage the reader. Embedded data viz can reveal trends, while the table itself shows the raw data for lookup.

```{r rule10data}

yield_data <- read_csv(here("data/yield_data.csv"))
country_sel <- c("China", "India", "United States", "Indonesia", "Mexico", "Pakistan")


rule10_data <- yield_data %>% 
  filter(
    year %in% c(2013,2017), 
    crop == "potatoes", 
    Country %in% c(
      country_sel, "Germany", "Brazil", "Ireland", "Lebanon", "Italy", 
      "Netherlands", "France", "Denmark", "El Salvador", "Denmark"
      )
    ) %>% 
    
      pivot_wider(names_from = year, values_from = yield)


  #  tab_header(
  #   title = md("Rule 10 Data"),
  #   subtitle = md("Add visualizations")
  # )
```

### 10. Sparklines

For example one we can use sparklines to indicate trends across time. There's quite a bit of code below, and we actually use two data sets. Since **we are creating the sparklines outside of gt** make sure to align the graphs + data as gt doesn't control the overall relationship. For example, if you arrange() by a specific column you'll need to make sure to do it across both data sets.

```{r}
plot_spark <- function(data){
  data %>% 
    mutate(
      yield_start = if_else(year == 2013, yield, NA_real_),
      yield_end = if_else(year == 2017, yield, NA_real_)
    ) %>% 
    tidyr::fill(yield_start, yield_end, .direction = "downup") %>% 
    mutate(color = if_else(yield_end-yield_start < 0, "red", "blue")) %>% 
    ggplot(aes(x = year, y = yield, color = color)) +
    geom_line(linewidth = 15) +
    theme_void() +
    scale_color_identity() +
    theme(legend.position = "none")
}

# SPARKLINE

yield_plots <- yield_data %>% 
  select(-code) %>% 
  filter(
    year %in% c(2013:2017), 
    crop == "potatoes", 
    Country %in% c(
      country_sel, "Germany", "Brazil", "Ireland", "Lebanon", "Italy", 
      "Netherlands", "France", "Denmark", "El Salvador", "Denmark"
    )
  ) %>% 
  nest(yields = c(year, yield)) %>% 
  mutate(plot = map(yields, plot_spark))

# SPARKLINES PLOT

rule10_spark <- rule10_data %>% 
  mutate(ggplot = NA) %>% 
  select(-crop, -code) %>% 
  gt() %>% 
  text_transform(
    locations = cells_body(columns = c(ggplot)),
    fn = function(x){
      map(yield_plots$plot, ggplot_image, height = px(15), aspect_ratio = 4)
    }
  ) %>% 
  cols_width(columns = c(ggplot) ~ px(100)) %>% 
  cols_label(
    ggplot = "2013-2017"
  ) %>% 
  fmt_number(2:3) %>% 
  tab_spanner(
    label = "Potato Yield in Tonnes/Hectare",
    columns = c(2,3)
  ) %>% 
  tab_style(
    style = cell_text(color = "black", weight = "bold"),
    locations = list(
      cells_column_spanners(everything()),
      cells_column_labels(everything())
    )
  ) %>%  
  tab_options(
    row_group.border.top.width = px(3),
    row_group.border.top.color = "black",
    row_group.border.bottom.color = "black",
    table_body.hlines.color = "white",
    table.border.top.color = "white",
    table.border.top.width = px(3),
    table.border.bottom.color = "white",
    table.border.bottom.width = px(3),
    column_labels.border.bottom.color = "black",
    column_labels.border.bottom.width = px(2),
  ) %>% 
  tab_source_note(md("**Table**: @thomas_mock | **Data**: OurWorldInData.org<br>**Inspiration**: @jschwabish"))
```

```{r}
rule10_spark
```

### 10. Barplot

For this example we can use bar plots to indicate the average across the 5 years. Note that rather than building a ggplot for each of the rows, we can take some influence from the *formattable* R package and create a bar with just HTML/CSS!

There's quite a bit of code below, but note that the gt package requires you to **parse the HTML with gt::html()**. Overall this method is "cleaner" than via ggplot as you are mutating columns within the same data set, and it's much faster since you are just parsing HTML rather than creating, saving, and importing several ggplot images.

Many thanks to the formattable author Renkun Kun and others like rtjohnson12 who have shown examples about how to build up a bar chart with HTML! Thanks also to Christophe Dervieux for a great example of gt + custom HTML on RStudio Community.

```{r}
# Example of using glue to just paste the value into pre-created HTML block
# Example adapted from rtjohnson12 at: 
# https://github.com/renkun-ken/formattable/issues/79#issuecomment-573165954

bar_chart <- function(value, color = "red", display_value = NULL){
  
  # Choose to display percent of total
  if (is.null(display_value)) {
    display_value <- "&nbsp;"
  } else {
    display_value <- display_value
  }
  
  # paste color and value into the html string
  glue::glue("<span style=\"display: inline-block; direction: ltr; border-radius: 4px; padding-right: 2px; background-color: {color}; color: {color}; width: {value}%\"> {display_value} </span>")
}

# create a color palette w/ paletteer
# note you could just pass a single color directly to the bar_chart function
col_pal <- function(value){
  
  # set high and low
  domain_range <- range(c(rule10_data$`2013`, rule10_data$`2017`))
  
  # create the color based of domain
  scales::col_numeric(
    paletteer::paletteer_d("ggsci::blue_material") %>% as.character(), 
    domain = c(min(value), max(value))
      )(value)
}

# BARPLOT

bar_yields <- yield_data %>% 
  filter(
    year %in% c(2013:2017), 
    crop == "potatoes", 
    Country %in% c(
      country_sel, "Germany", "Brazil", "Ireland", "Lebanon", "Italy", 
      "Netherlands", "France", "Denmark", "El Salvador", "Denmark"
      )
    ) %>% 
  pivot_wider(names_from = year, values_from = yield) %>%  
  select(-crop) %>% 
  rowwise() %>% 
  mutate(
    mean = mean(c(`2013`, `2014`, `2015`, `2016`, `2017`))
    ) %>% 
  ungroup() %>% 
  select(Country, `2013`, `2017`, `mean`) %>% 
  mutate(
    bar = round(mean/max(mean)*100, digits = 2),
    color = col_pal(bar),
    bar_chart = bar_chart(bar, color = color),
    bar_chart = map(bar_chart, ~gt::html(as.character(.x)))) %>% 
  select(-bar, -color)
  
# BARPLOT

rule10_bar <- bar_yields %>% 
  gt() %>% 
  cols_width(columns = c(bar_chart) ~ px(100),
             columns = c(`2013`) ~ px(75),
             columns = c(`2017`) ~ px(75)
             ) %>% 
  cols_label(
    mean = md("Average<br>2013-17"),
    bar_chart = ""
  ) %>% 
  cols_align(
    align = "right",
    columns = 2:4
  ) %>% 
  cols_align(
    align = "left",
    columns = c(bar_chart)
  ) %>% 
  fmt_number(2:4) %>% 
  tab_style(
    style = cell_text(color = "black", weight = "bold"),
    locations = list(
      cells_column_labels(everything())
    )
  ) %>%  
  tab_options(
    row_group.border.top.width = px(3),
    row_group.border.top.color = "black",
    row_group.border.bottom.color = "black",
    table_body.hlines.color = "white",
    table.border.top.color = "white",
    table.border.top.width = px(3),
    table.border.bottom.color = "white",
    table.border.bottom.width = px(3),
    table_body.border.bottom.width = px(2),
    table_body.border.bottom.color = "black",
    column_labels.border.bottom.color = "black",
    column_labels.border.bottom.width = px(3)
  ) %>% 
  tab_footnote(footnote = "Potato Yield in Tonnes per Hectare",
               locations = cells_column_labels(
                 columns =2:4
               )) %>% 
  tab_source_note(md("**Table**: @thomas_mock | **Data**: OurWorldInData.org<br>**Inspiration**: @jschwabish"))
```

```{r}
rule10_bar
```

### 10. Heatmap

Lastly, you can add colors across the entire plot itself to show trends across the data over time and across country.

**Rule 10 \| Heatmap example gt code**

```{r}
rule10_wide <- yield_data %>% 
  filter(
    year %in% c(2013:2017), 
    crop == "potatoes", 
    Country %in% c(
      country_sel, "Germany", "Brazil", "Ireland", "Lebanon", "Italy", 
      "Netherlands", "France", "Denmark", "El Salvador", "Denmark"
    )
  ) %>% 
  pivot_wider(names_from = year, values_from = yield)

rule10_heat <- rule10_wide %>% 
  arrange(desc(`2013`)) %>% 
  select(-crop, -code) %>% 
  gt() %>% 
  data_color(
    columns = 2:6, 
    colors = scales::col_numeric(
      palette = paletteer::paletteer_d(
        palette = "ggsci::blue_material"
      ) %>% as.character(),
      domain = NULL
    )
  ) %>% 
  fmt_number(2:6) %>% 
  tab_spanner(
    label = "Potato Yield in Tonnes/Hectare",
    columns = c(2:6)
  ) %>% 
  tab_style(
    style = cell_text(color = "black", weight = "bold"),
    locations = list(
      cells_column_spanners(everything()),
      cells_column_labels(everything())
    )
  ) %>%  
  cols_width(
    1 ~ px(125),
    2:6 ~ px(65)
  ) %>% 
  tab_options(
    row_group.border.top.width = px(3),
    row_group.border.top.color = "black",
    row_group.border.bottom.color = "black",
    table_body.hlines.color = "white",
    table.border.top.color = "white",
    table.border.top.width = px(3),
    table.border.bottom.color = "white",
    table.border.bottom.width = px(3),
    column_labels.border.bottom.color = "black",
    column_labels.border.bottom.width = px(2),
  ) %>% 
  tab_source_note(md("**Table**: @thomas_mock | **Data**: OurWorldInData.org<br>**Inspiration**: @jschwabish"))
```

```{r}
rule10_heat

```

### 10. Percent Change

One more example, with color for a numeric column.

**Rule 10 \| Percent change example gt code**

```{r rule10_wide}

rule10_wide <- yield_data %>% 
  select(-code) %>% 
  filter(
    year %in% c(2013:2017), 
    crop == "potatoes", 
    Country %in% c(
      country_sel, "Germany", "Brazil", "Ireland", "Lebanon", "Italy", 
      "Netherlands", "France", "Denmark", "El Salvador", "Denmark"
    )
  ) %>% 
  pivot_wider(names_from = year, values_from = yield)

rule10_pct <- rule10_wide %>% 
  arrange(Country) %>% 
  select(-crop) %>% 
  mutate(pct_change = (`2017`/`2013`-1)*100) %>% 
  gt()%>% 
  fmt_number(2:7) %>% 
  cols_label(
    pct_change = md("Percent Change")
  ) %>% 
  tab_style(
    style = list(
      cell_text(color = "red")
    ),
    locations = cells_body(
      columns = c(pct_change),
      rows = pct_change <= 0
    )
  ) %>% 
  tab_style(
    style = list(
      cell_text(color = "blue")
    ),
    locations = cells_body(
      columns = c(pct_change),
      rows = pct_change > 0
    )
  ) %>% 
  tab_spanner(
    label = "Potato Yield in Tonnes/Hectare",
    columns = c(2:6)
  ) %>% 
  tab_style(
    style = cell_text(color = "black", weight = "bold"),
    locations = list(
      cells_column_spanners(everything()),
      cells_column_labels(everything())
    )
  ) %>%  
  tab_options(
    row_group.border.top.width = px(3),
    row_group.border.top.color = "black",
    row_group.border.bottom.color = "black",
    table_body.hlines.color = "white",
    table.border.top.color = "white",
    table.border.top.width = px(3),
    table.border.bottom.color = "white",
    table.border.bottom.width = px(3),
    column_labels.border.bottom.color = "black",
    column_labels.border.bottom.width = px(2),
  ) %>% 
  tab_source_note(md("**Table**: @thomas_mock | **Data**: OurWorldInData.org<br>**Inspiration**: @jschwabish"))
```

```{r plot_rule10_pct}
rule10_pct

```

### Rule 11: Add Context to the Table

I'll add one more guideline of my own! We've been playing fairly fast and loose with not naming many of the tables and not providing all the context about even what's in the table, mostly because we're more concerned with showing curated and specific examples. However, naming and adding context to the table is important. This can be accomplished many different ways with gt.

### Add a title

Going back to our first table - let's tell the reader what the actual data is!

```{r}
rule1_good %>% 
  tab_header(
    title = md("**Potato yields in 6 major countries**"),
    subtitle = "Yield in Tonnes/Hectare"
    ) %>% 
  tab_options(heading.align = "left",
              table.border.top.color = "white",
              table.border.top.width = px(3))
```

### Add a a Footer

Alternatively, we could also add a footer to column labels to explain the yields.

```{r}
rule1_good %>% 
  tab_footnote(
    footnote = "Annual Potato Yield in Tonnes/Hectare",
    locations = cells_column_labels(2:5)
  )
```

### Redo an example

Going a bit further into our rule 10 examples, while we added some nice color - we could further clarify the percent change, was it the sum of changes? Change from specific years? It was just the change from 2013 vs 2017.

```{r}
rule10_pct %>% 
  tab_footnote(
    "Percent Change: 2013 vs 2017",
    locations = cells_column_labels(7)
  )
```

What about our lovely table that had both column and row summaries? We renamed our column summaries to just Avg. and Avg. - we can assume that the reader understands it is the summary of the columns to their immediate left, but it can be helpful to also explicitly tell the reader what the calculation is. What if the second Avg. was in fact the average from all years (2007 to 2016), rather than just 2012 through 2016?

```{r}
rule2_data <- yield_data %>% 
  filter(Country %in% country_sel, crop == "potatoes", year %in% c(2007:2016)) %>% 
  filter(crop == "potatoes") %>% 
  select(-crop) %>% 
  pivot_wider(names_from = year, values_from = "yield") %>% 
  rowwise() %>% 
  mutate(
    avg_07_11 = mean(`2007`:`2011`),
    .before = `2012`
    ) %>% 
  mutate(
    avg_12_16 = mean(`2012`:`2016`)
  ) %>% 
  ungroup()

rule2_tab2 <- rule2_data %>% 
  gt() %>% 
  tab_style(style = cell_fill(color = "lightgrey"),
                   locations = cells_body(columns = c("avg_07_11", "avg_12_16")))

```

```{r}
rule2_tab2 %>% 
  tab_source_note(md("**Table**: @thomas_mock | **Data**: OurWorldInData.org<br>**Inspiration**: @jschwabish")) %>% 
  tab_footnote(
    footnote = "Average of 2007 through 2011",
    locations = cells_column_labels(columns = c(avg_07_11))
  ) %>% 
  tab_footnote(
    footnote = "Average of 2012 through 2016",
    locations = cells_column_labels(columns = c(avg_12_16))
  ) 
```

```{r}
knitr::knit_exit()
```
